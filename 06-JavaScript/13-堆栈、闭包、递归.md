# 堆栈、闭包、递归



## 1. JS 堆栈内存释放

堆内存：存储引用类型值，对象类型就是键值对，函数就是代码字符串

堆内存释放：将引用类型的空间地址变量赋值成 `null`，或没有变量占用堆内存了浏览器就会释放掉这个地址

栈内存：提供代码执行的环境和存储基本类型值

栈内存释放：一般当函数执行完后函数的私有作用域就会被释放掉

栈内存的释放也有特殊情况：

* 函数执行完，但是函数的私有作用域内有内容被栈外的变量还在使用的，栈内存就不能释放里面的基本值也就不会被释放

* 全局下的栈内存只有页面被关闭的时候才会被释放



## 2. 闭包

### 2-1 闭包的概念

**MDN定义：**闭包是由函数以及声明该函数的词法环境组合而成的。该词法环境包含了这个闭包创建时作用域内的任何局部变量

**自己理解：**闭包就是一个函数引用另一个函数内部的变量，因为变量被引用着，所以当另外一个函数执行结束会相应的执行上下文弹出栈时， 变量并不会被回收，因此可以用来封装一个私有变量

**闭包中的变量存储的位置是堆内存**

```js
// 在函数中return一个函数
var str = '全局'

function outerFn() {
	var str = 'jsx';

	function inside() {
		console.log(str);
	}
	return inside;
}

let myFunc = outerFn();
myFunc(); // jsx
```



### 2-2 闭包的优缺点

**闭包的用处：**

* 读取函数内部的变量
* 这些变量的值始终保持在内存中，不会在外层函数调用后被自动清除



**闭包的特性：**

* 函数套函数
* 函数内部可以直接使用外部函数的变量或者参数
* 变量或参数不会被垃圾回收机制回收



**闭包的优点：**

* 避免全局变量的污染

- 保护函数的私有变量不受外部的干扰，形成不销毁的栈内存

- 把一些函数内的值保存下来，闭包可以实现方法和属性的私有化



**闭包的缺点：**

*  常驻内存 会增大内存的使用量 使用不当会造成内存泄露
* 闭包会在父函数外部，改变父函数内部变量的值



```js
function add(x) {
	return function(y) {
		return x + y;
	}
}

let add3 = add(3);
let add5 = add(5);
console.log(add3(5));
console.log(add5(5));
// 释放对闭包的引用
add5 = null;
console.log(add5(1)); //Uncaught TypeError: add5 is not a function
```



### 2-3 使用场景

* 函数作为参数

`myFunc()` 执行完毕后，里面的变量 `str` 没有被回收，被 `returnFunc()` 引用着，此时 `myFunc()` 与其词法环境就是一个闭包

```js
var str = 'ddc';

function myFunc() {
	var str = 'jsx';

	function returnFunc() {
		console.log(str);
	}
	return returnFunc;
}

function getStr(fun) {
	var str = 'ljj';
	fun();
}
getStr(myFunc()); // jsx
```



* 立即执行函数 `IIFE`

把 `function () {return num += 1;}` 返回给`now`变量， 执行`now()`时就是执行 `function () {return num += 1;}` 此时的 `num`  变量未声明，引用着立即执行函数里的 `num` 变量，立即执行函数执行后未将变量销毁形成闭包

```js
var now = (function() {
	var num = 0;
	return function() {
		return num += 1
	}
})();
console.log(now()); // 1
console.log(now()); // 2
```



* `for` 循环定时器赋值

变量`i`是 `var` 命令声明的，在全局范围内都有效，所以全局只有一个变量`i`。每一轮循环，变量`i`的值都会覆盖上一轮的值

JS 是单线程的遇到异步的代码不会先执行会入栈，等到同步的代码执行完 `i++` 到 3 时，异步代码才开始执行此时的 `i = 3` 输出的都是 3

```js
var i = 2;
for (var i = 0; i < 3; i++) {
	setTimeout(() => {
		console.log(i) // 3 3 3
	})
}
```



变量 `i` 是 `let` 声明的，当前的 `i` 在本轮循环有效，所以每一次循环的`i`其实都是一个新的变量

```js
// 通过let时变量拥有块级作用域
for (let i = 0; i < 3; i++) {
	setTimeout(() => {
		console.log(i) // 0 1 2
	})
}
```



通过自执行函数解决，会为每一轮循环都生成一个新的函数作用域

变量 `j` 就是闭包的一部分，立即执行函数执行结束时，变量 `j` 被定时器引用着

```js
for (var i = 0; i < 3; i++) {
	(function(j) {
		setTimeout(() => {
			console.log(j); // 0 1 2
		})
	})(i)
}
```



* 回调函数

使用回调函数就是在使用闭包

```js
function callback(num) {
	console.log(num);
}

function getBack(call) {
	var str = 'oj8k';
	call(str);
}
getBack(callback) // oj8k
```



## 3. 递归

递归，就是在运行的过程中调用自己

递归必须要具备的条件:

- 自身调用：原问题可以分解为子问题，子问题和原问题的求解方法是一致的，即都是调用自身的同一个函数
- 终止条件：递归必须有一个终止的条件，即不能无限循环地调用本身

```js
// 递归求和
function add(n) {
	if (n == 1) return 1
	return add(n - 1) + n
}
console.log(add(5)); // 15
```

解决递归问题三步曲，分别是：

- 第一步，定义函数功能
- 第二步，寻找递归终止条件
- 第二步，递推函数的等价关系式
